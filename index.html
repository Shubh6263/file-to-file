<!DOCTYPE html>
<html lang="en">
<head>
    <!-- [Previous head content remains exactly the same] -->
</head>
<body>
    <!-- [Previous HTML structure remains the same until the script section] -->

    <script>
        // ===== GLOBAL UTILITIES ===== //
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function showProgress(containerId, percent, message = '') {
            const container = document.getElementById(containerId);
            const bar = container.querySelector('.progress');
            const text = container.querySelector('.progress-text span:first-child');
            const percentEl = container.querySelector('.progress-text span:last-child');
            
            container.style.display = 'block';
            bar.style.width = `${percent}%`;
            if (message) text.textContent = message;
            percentEl.textContent = `${percent}%`;
        }

        function hideProgress(containerId) {
            document.getElementById(containerId).style.display = 'none';
        }

        function showResult(containerId) {
            document.getElementById(containerId).style.display = 'block';
        }

        // ===== FILE UPLOAD HANDLING ===== //
        document.querySelectorAll('.upload-area').forEach((area, index) => {
            const input = area.querySelector('input[type="file"]');
            const fileList = document.getElementById(area.id.replace('upload', 'file-list'));
            
            area.addEventListener('click', () => input.click());
            
            area.addEventListener('dragover', (e) => {
                e.preventDefault();
                area.classList.add('active');
            });
            
            area.addEventListener('dragleave', () => area.classList.remove('active'));
            
            area.addEventListener('drop', (e) => {
                e.preventDefault();
                area.classList.remove('active');
                input.files = e.dataTransfer.files;
                updateFileList(input, fileList);
            });
            
            input.addEventListener('change', () => updateFileList(input, fileList));
        });

        function updateFileList(input, fileListElement) {
            fileListElement.innerHTML = '';
            if (input.files.length > 0) {
                Array.from(input.files).forEach((file, i) => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    fileItem.innerHTML = `
                        <div class="file-info">
                            <i class="fas fa-file-alt file-icon"></i>
                            <span class="file-name" title="${file.name}">${file.name}</span>
                        </div>
                        <span class="file-size">${formatFileSize(file.size)}</span>
                        <i class="fas fa-times file-remove" data-index="${i}"></i>
                    `;
                    fileListElement.appendChild(fileItem);
                    
                    fileItem.querySelector('.file-remove').addEventListener('click', (e) => {
                        e.stopPropagation();
                        const newFiles = Array.from(input.files).filter((_, idx) => idx != e.target.dataset.index);
                        const dataTransfer = new DataTransfer();
                        newFiles.forEach(f => dataTransfer.items.add(f));
                        input.files = dataTransfer.files;
                        updateFileList(input, fileListElement);
                    });
                });
            }
        }

        // ===== ZIP TOOL FUNCTIONALITY ===== //
        document.getElementById('compress-btn').addEventListener('click', async () => {
            const files = document.getElementById('zip-input').files;
            if (files.length === 0) {
                alert('Please select files to compress');
                return;
            }
            
            const level = parseInt(document.getElementById('compression-level').value);
            const progressId = 'zip-progress';
            
            showProgress(progressId, 0, 'Compressing files...');
            
            try {
                const zip = new JSZip();
                let processed = 0;
                
                // Add files to zip
                for (let file of files) {
                    const content = await readFileAsArrayBuffer(file);
                    zip.file(file.name, content, { compression: 'DEFLATE', compressionOptions: { level } });
                    processed++;
                    showProgress(progressId, Math.round((processed / files.length) * 100));
                }
                
                // Generate zip file
                const content = await zip.generateAsync({ type: 'blob' }, metadata => {
                    showProgress(progressId, metadata.percent);
                });
                
                // Create download link
                const downloadBtn = document.getElementById('download-zip');
                downloadBtn.href = URL.createObjectURL(content);
                downloadBtn.download = 'archive.zip';
                
                // Show result
                document.getElementById('zip-output-size').textContent = formatFileSize(content.size);
                showResult('zip-result');
                
            } catch (error) {
                console.error('ZIP error:', error);
                alert('Error creating ZIP file');
            } finally {
                hideProgress(progressId);
            }
        });

        // ===== IMAGE TO PDF FUNCTIONALITY ===== //
        document.getElementById('img-pdf-btn').addEventListener('click', async () => {
            const files = document.getElementById('img-pdf-input').files;
            if (files.length === 0) {
                alert('Please select images to convert');
                return;
            }
            
            const progressId = 'img-pdf-progress';
            showProgress(progressId, 0, 'Creating PDF...');
            
            try {
                const { PDFDocument, rgb } = PDFLib;
                const pdfDoc = await PDFDocument.create();
                let processed = 0;
                
                for (let file of files) {
                    if (!file.type.startsWith('image/')) continue;
                    
                    const imgBytes = await readFileAsArrayBuffer(file);
                    let image;
                    
                    if (file.type === 'image/jpeg') {
                        image = await pdfDoc.embedJpg(imgBytes);
                    } else if (file.type === 'image/png') {
                        image = await pdfDoc.embedPng(imgBytes);
                    } else {
                        continue; // Skip unsupported formats
                    }
                    
                    const page = pdfDoc.addPage([image.width, image.height]);
                    page.drawImage(image, {
                        x: 0,
                        y: 0,
                        width: image.width,
                        height: image.height,
                    });
                    
                    processed++;
                    showProgress(progressId, Math.round((processed / files.length) * 100));
                }
                
                const pdfBytes = await pdfDoc.save();
                const pdfBlob = new Blob([pdfBytes], { type: 'application/pdf' });
                
                // Create download link
                const downloadBtn = document.getElementById('download-img-pdf');
                downloadBtn.href = URL.createObjectURL(pdfBlob);
                downloadBtn.download = 'converted.pdf';
                
                // Show result
                document.getElementById('img-pdf-output-size').textContent = formatFileSize(pdfBlob.size);
                showResult('img-pdf-result');
                
            } catch (error) {
                console.error('PDF creation error:', error);
                alert('Error creating PDF');
            } finally {
                hideProgress(progressId);
            }
        });

        // ===== PDF TO IMAGE FUNCTIONALITY ===== //
        document.getElementById('pdf-img-btn').addEventListener('click', async () => {
            const file = document.getElementById('pdf-img-input').files[0];
            if (!file) {
                alert('Please select a PDF file');
                return;
            }
            
            const progressId = 'pdf-img-progress';
            showProgress(progressId, 0, 'Converting PDF pages...');
            
            try {
                const format = document.querySelector('input[name="img-format"]:checked').value;
                const pdfData = await readFileAsArrayBuffer(file);
                
                // Load the PDF
                const loadingTask = pdfjsLib.getDocument({ data: pdfData });
                const pdf = await loadingTask.promise;
                const images = [];
                
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const viewport = page.getViewport({ scale: 1.5 });
                    
                    // Create canvas for rendering
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    
                    // Render PDF page to canvas
                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;
                    
                    // Convert canvas to image
                    const imageBlob = await new Promise(resolve => {
                        canvas.toBlob(blob => resolve(blob), `image/${format}`, 0.85);
                    });
                    
                    images.push({
                        blob: imageBlob,
                        name: `${file.name.replace('.pdf', '')}_page${i}.${format}`
                    });
                    
                    showProgress(progressId, Math.round((i / pdf.numPages) * 100));
                }
                
                // Create ZIP of all images
                const zip = new JSZip();
                images.forEach(img => {
                    zip.file(img.name, img.blob);
                });
                
                const zipBlob = await zip.generateAsync({ type: 'blob' });
                
                // Create download link
                const downloadBtn = document.getElementById('download-pdf-img');
                downloadBtn.href = URL.createObjectURL(zipBlob);
                downloadBtn.download = 'extracted_images.zip';
                
                // Show result
                document.getElementById('pdf-img-output-size').textContent = formatFileSize(zipBlob.size);
                showResult('pdf-img-result');
                
            } catch (error) {
                console.error('PDF to image error:', error);
                alert('Error converting PDF to images');
            } finally {
                hideProgress(progressId);
            }
        });

        // ===== IMAGE RESIZER FUNCTIONALITY ===== //
        document.getElementById('resize-btn').addEventListener('click', async () => {
            const files = document.getElementById('resize-input').files;
            if (files.length === 0) {
                alert('Please select images to resize');
                return;
            }
            
            const progressId = 'resize-progress';
            showProgress(progressId, 0, 'Resizing images...');
            
            try {
                const zip = new JSZip();
                const mode = document.querySelector('input[name="resize-mode"]:checked').value;
                const format = document.querySelector('input[name="resize-format"]:checked').value;
                const quality = parseInt(document.getElementById('resize-quality').value) / 100;
                let processed = 0;
                
                for (let file of files) {
                    if (!file.type.startsWith('image/')) continue;
                    
                    const img = await createImageBitmap(file);
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Calculate new dimensions
                    let width, height;
                    if (mode === 'percentage') {
                        const percent = parseInt(document.getElementById('resize-percentage').value) / 100;
                        width = img.width * percent;
                        height = img.height * percent;
                    } else {
                        width = parseInt(document.getElementById('resize-width').value);
                        height = parseInt(document.getElementById('resize-height').value);
                        if (document.getElementById('maintain-ratio').checked) {
                            const ratio = img.width / img.height;
                            if (width / height > ratio) {
                                width = height * ratio;
                            } else {
                                height = width / ratio;
                            }
                        }
                    }
                    
                    // Resize image
                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Convert to blob
                    const outputFormat = format === 'original' ? file.type.split('/')[1] : format;
                    const mimeType = `image/${outputFormat}`;
                    
                    const blob = await new Promise(resolve => {
                        canvas.toBlob(resolve, mimeType, quality);
                    });
                    
                    // Add to zip
                    const ext = outputFormat === 'jpeg' ? 'jpg' : outputFormat;
                    zip.file(`${file.name.split('.')[0]}_resized.${ext}`, blob);
                    
                    processed++;
                    showProgress(progressId, Math.round((processed / files.length) * 100));
                }
                
                // Generate zip file
                const zipBlob = await zip.generateAsync({ type: 'blob' });
                
                // Create download link
                const downloadBtn = document.getElementById('download-resize');
                downloadBtn.href = URL.createObjectURL(zipBlob);
                downloadBtn.download = 'resized_images.zip';
                
                // Show result
                document.getElementById('resize-output-size').textContent = formatFileSize(zipBlob.size);
                showResult('resize-result');
                
            } catch (error) {
                console.error('Resize error:', error);
                alert('Error resizing images');
            } finally {
                hideProgress(progressId);
            }
        });

        // ===== HELPER FUNCTIONS ===== //
        function readFileAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        // ===== TAB SWITCHING ===== //
        document.querySelectorAll('.tab-btn').forEach(button => {
            button.addEventListener('click', () => {
                document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                
                const toolId = button.getAttribute('data-tool');
                document.querySelectorAll('.tool-card').forEach(card => {
                    card.style.display = card.id === `${toolId}-tool` ? 'block' : 'none';
                });
            });
        });

        // Initialize first tool
        document.querySelector('.tab-btn.active').click();
    </script>
</body>
</html>
